#### 基本原理

##### 组件渲染

1. 调用 `render()` 方法创建一个的 `DOM` 树，并挂载到根元素上。
2. 当 `state` 或 `props` 更新时，重新调用 `render()` 方法，并返回新的 `DOM` 树。
3. 比较新的 `DOM` 树，与旧 `DOM` 树之间的差异，从外层开始到内层依次比较，当元素不相同时则卸载该元素和其内包含的所有元素；当元素相同时，则不会卸载元素，再进行元素属性比较，更新元素属性，同时更新 `state` 和 `props` ，可以看到 `React` 更新元素属性和状态开销是很小的。

##### 为什么列表渲染要使用key？

当新旧 `DOM` 树列表进行比较时，当新增元素在列表末尾时，如下：

```react
//旧DOM
<ul>
    <li>one</li>
    <li>two</li>
</ul>

//新DOM
<ul>
    <li>one</li>
    <li>two</li>
    <li>thr</li>
</ul>
```

`React` 会匹配到前两个对应的 `DOM` 树，发现只需要在旧的 `DOM` 树中插入一项新的就可以了，这时 `React` 不会卸载整个旧 `DOM` 树。

若新增元素在列表的开头时，如下：

```react
//旧DOM
<ul>
    <li>one</li>
    <li>two</li>
</ul>

//新DOM
<ul>
    <li>thr</li>
    <li>one</li>
    <li>two</li>
</ul>
```

`React` 进行比较时，会认为 `<ul>` 元素内的节点都已经改变，所以会卸载全部 `<ul>` 的子元素，然后重建，这时开销就会比较大。但若给每一个 `<li>` 元素加上 `key` 标签，`React` 在检查时会意识到只是新增了一项子元素，而其他两个元素还可以使用，这时 `React` 就只建立一个新增的元素，可以节省开销。