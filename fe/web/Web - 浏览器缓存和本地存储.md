#### Web 浏览器缓存和本地存储

##### 浏览器缓存

1. **概述：**浏览器的缓存分为强缓存和协商缓存，强缓存不需要发送HTTP请求，协商缓存需要需要发送HTTP请求。

2. **强缓存**

   浏览器在使用缓存的时候会先通过相应字段检查强缓存是否可用，如果可用则直接使用。表示强缓存是否可用的字段在`HTTP/1.0`使用 Expires，在`HTTP/1.1`使用 Cache-Control。注意，当Expires和Cache-Control同时存在时，浏览器优先考虑Cache-Control。

   Expires存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可用直接从缓存中获取数据，无需再次请求。如：`Expires: web, 11 Nov 2020 00:00:00 GMT`表示资源在`2020年11月11日0点0分`过期，过期了就得向服务器发送请求。但Expires有一个缺点就是，有时候服务器的时间和浏览器的时间可能不一致，所以在`HTTP1.1`中不在使用这种方法了。

   Cache-Control也是存在于服务端返回的响应头中，但它不是使用过期时间来控制缓存，而是使用过期时长，如：`Cache-Control: max-age=3000`表示在响应返回后的3000秒内可以直接使用缓存。`Cache-Control`还有很多指令，关键属性如下：

   1. `public`：表示客户端和代理服务器都可以缓存。
   2. `private`：表示只有浏览器可以缓存，中间的代理服务器不能缓存。
   3. `no-cache`：表示跳过当前的强缓存，发送HTTP请求，即直接进入协商缓存阶段。
   4. `no-store`：表示不进行任何形式的缓存。
   5. `s-maxage`：表示代理服务器的缓存事件。

3. **协商缓存**

   强缓存失效后，浏览器在请求头中携带响应的`缓存tag`向服务器发送请求，由服务器根据`缓存tag`来判断是否继续使用这个强缓存。`缓存tag`分为两种：Last-Modified和ETag。注意，当两种方式同时存在时，浏览器优先考虑ETag。

   Last-Modified即最后修改时间，浏览器第一次给服务器发送请求后，服务器会在响应头中加入这个字段。浏览器收到响应后，如果再次请求，会在请求头中携带`If-Modified-Since`字段，这个字段的值就是服务器传来的最后修改的时间。服务器拿到请求头中的`If-Modified-Since`字段后，会和服务器中该资源的最后修改时间对比，如果该字段的值小于最后修改时间，则表示浏览器需要更新该资源，则返回新资源（根常规HTTP请求响应的流程一样）；否则返回304，告诉浏览器直接使用缓存。

   Etag是服务器根据当前文件的内容给文件生成的唯一标识，只要文件内容改变，这个值就会跟踪改变。服务器通过响应头把这个值传递给浏览器。浏览器接收到响应后，如果再次请求，会在请求头中携带`If-None-Match`字段，这个字段的值就是服务器传来的ETag。服务器拿到请求头中的`If-None-Match`字段后，会与服务器上该资源的ETag进行对比，两者不一样，说明资源有改动，则返回新的资源；否则返回304，告诉浏览器直接使用缓存。

4. **缓存位置**

   浏览器中的缓存位置一个有四种，按优先级从高到底分别是：

   1. Service Worker
   2. Memory Cache：内存缓存，它在效率上是最快的，但存活时间最短，当渲染进程结束后它就不存在了。
   3. Disk Cache：磁盘缓存。
   4. Push Cache：推送缓存，它是`HTTP/2`中的内容。

5. **总结**：浏览器在使用缓存是先检查强缓存是否可用，如果可用直接使用；如果不能使用则进入协商缓存，此时发送HTTP请求，查看资源是否更新，若资源更新返回新资源和200状态码，若没有更新返回304，继续使用缓存中的资源。

##### 浏览器的本地存储

1. **概念：**浏览器的本地存储主要分为`Cookie`、`WebStorage`、`IndexedDB`，其中`WebStorage`又分为`localStorage`和`sessionStorage`。

2. **Cookie：**Cookie是为了弥补HTTP在状态管理上的缺陷，因为HTTP协议是无状态协议，当客户端向服务端发送请求，服务端响应后就完成了，当客户端再次向服务端发送请求时，服务端并不知道客户端是谁，为了能让服务端识别客户端就创造了Cookie。Cookie是浏览器存储的一个很小的文件，内部已键值对的方式存储(在chrome开发者面板的Application这一栏可以看到)，向同一个域名下发送请求，都会携带相同的Cookie，服务器拿到Cookie进行解析，便能拿到客户端的状态。

   Cookie的缺点：

   - 容量缺陷：Cookie 的体积上限只有4KB，只能用来存储少量的信息。
   - 性能缺陷：Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。
   - 安全缺陷：由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，这时在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在HttpOnly为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。

3. **localStorage：**与Cookie一样，针对一个域名会存储相同的数据。

   与Cookie的区别是：

   - 容量：容量上限是5M。
   - 只存在客户端，默认不参与服务端的通信，避免了Cooke带来的性能和安全问题。
   - 接口封装。通过`localStorage`暴露在全局。

   利用localStorage的较大容量和持久性特征，可以存储原型内容稳定的资源，如官网的logo等

4. **sessionStorage：**与localStorage一样，唯一的区别是sessionStorage是会话级别的存储，页面关闭就消失了。可以用它对表单信息进行维护，表单信息存储在里面，保证页面刷新也不会让之前的表单信息丢失。也可以用来存储本次浏览记录(如果页面关闭就不在需要这些记录了)。

5. **IndexedDB：**运行在浏览器中的菲关系型数据库。存储上限不限。

