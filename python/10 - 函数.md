#### 函数

- `def`：定义函数

  ```python
  def fName(args):
      statements
  ```

  其实函数就是一个对象，`def` 后面的函数名只是当前作用域中的一个变量赋值，就好像 `a = 1 ` 一样，所以可以把函数名所引用的对象赋值给其他名称，然后调用。

- `fName(args)`：调用函数

- `return`：函数的返回值，没有返回值的 `return` 语句将返回默认值 `None` 。

- `global`：声明一个模块级的可被赋值的变量。

- `nonlocal`：声明了一个需要被赋值的外层函数变量。

- `yield`：向调用者发回一个结果对象，但会记住它离开的位置。

- `lambda`：创建一个对象并将其作为结果返回。

##### 内聚性个耦合性

内聚性：如何将任务分解成更有针对性的函数。

耦合性：函数如何通信。

一般原则：

1. 耦合性：输入时使用参数，输出时使用 `return` 语句，让函数尽量独立于它的外部东西。
2. 耦合性：只在真正必要的情况下使用全局变量。
3. 耦合性：不要改变可变类型的参数，触发调用者希望这样做，函数可以改变传入的可变类型对象，但是向这样向全局变量一样，会导致调用者和被调用者之间的强耦合性。
4. 内聚性：每个函数都应该有一个单一的、统一的目标。
5. 大小：每个函数应该相对较小，如果函数过长应该考虑把它分开。
6. 耦合性：避免直接改变其他模块文件中的变量。

##### 递归函数

递归函数：直接或间接地调用自身以进行循环的函数。递归求和示例：

```python
def f(L):
    if not L:
        return 0
    else:
        return L[0] + f(L[1:])
f([1, 2 ,3]) #输出6
```

递归和循环语句：一般来说能用循环和递归来解决的，循环的效率更高且更易理解，但递归可以处理某些循环无法处理的情况，如计算嵌套列表中所有的数字的和：

```python
one = [1, [2, [3, 4],5], 6, [7, 8]]
def sumtree(L):
    sum = 0
    for x in L:
        if not isinstance(x, list): #判断x是否是list类型
            sum += x
        else:
            sum += sumtree(x)
    return sum
sumtree(one) #输出
```

##### 函数注解

函数注解出现在 `def` 头部行，作为与参数和返回值相关的任意表达式。函数注解对于参数，出现在紧随参数名之后的冒号之后；对于返回值，出现在紧跟在参数列表之后的 `->` 符号后面；示例如下：

```python
def f(a: 'spam' ,b, c: 'spam' ) -> int:
    return a + b + c
#使用了注解的参数依然可以交易使用参数默认值
def f(a: 'spam' = 1 ,b, c: 'spam' = 2 ) -> int:
    return a + b + c
```

使用 `函数名.__annotations__` 可以查看函数的注解，函数的注解的应用还在开发中。

##### 匿名函数

`lambda` 表达式创建一个之后能够调用的函数，由于它返回函数本身而不是将其赋值给一个变量，由此称他为匿名函数。由于 `lambda` 是一个表达式不是一个语句，所以 `lambda` 能够在 `def` 不能出现的地方出现。`lambda` 通常用来在不必要使用 `def` 地方创建小的的代码片段，如创建列表 `lambda`：

```python
L = [
    lambad x: x ** 2,
    lambda x: x ** 3,
    lambda x: x ** 4
]
for f in L:
    print(f(2)) #输出 4，8，16
    
print(L[0](2)) #输出 4
```

创建字典 `lambda` ：

```python
D = {
    "one": lambda: 2 + 2,
    "two": (lambda: 2 + 2),
    "thr": lambda x: x ** 2,
    "fou": (lambda x: x ** 2),
}
D["one"]() #输出 4
D["two"]() #输出 4
D["thr"](3) #输出 9
D["fou"](3) #输出 9
```

注意，为了代码的可读性尽量避免 `lambda` 的嵌套使用。

##### 函数式编程工具

- **`map()`**：将被传入的函数参数作用到一个可迭代对象的每一个元素上，并返回包含了所有这些函数调用结果的一个可迭代对象，如：

  ```python
  L = [1, 2, 3]
  def f(x): 
      return x**2
  list(map(f, L)) #返回：[1, 4, 9]，map()返回了一个可迭代对象，list()将迭代对象格式化为列表
  
  list(map((lambda x, y=1: x**2+y), L)) #返回：[2, 5, 10]
  ```

- **`filter()`**：将传入的函数参数作用到一个可迭代对象的每一个元素上，并返回包含了所有这些函数调用结果返回 `true` 的元素组成的可迭代对象，如：

  ```python
  L = [1, 2, 3]
  list(filter((lambda x: x>=2), L)) #返回：[2, 3]
  ```

- **`reduce()`**：合并可迭代对象中的元素。如：

  ```python
  from functools import reduce # reduce位于functools模块中
  L = ["a", "b", "c"]
  reduce((lambda x, y: x+y)) #返回：'abc'
  ```

  