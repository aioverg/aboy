#### 函数

- `def`：定义函数

  ```python
  def fName(args):
      statements
  ```

  

- `fName(args)`：调用函数

- `return`：函数的返回值，没有返回值的 `return` 语句将返回默认值 `None` 。

- `global`：声明一个模块级的可被赋值的变量。

- `nonlocal`：声明了一个需要被赋值的外层函数变量。

- `yield`：向调用者发回一个结果对象，但会记住它离开的位置。

- `lambda`：创建一个对象并将其作为结果返回。

##### 内聚性个耦合性

内聚性：如何将任务分解成更有针对性的函数。

耦合性：函数如何通信。

一般原则：

1. 耦合性：输入时使用参数，输出时使用 `return` 语句，让函数尽量独立于它的外部东西。
2. 耦合性：只在真正必要的情况下使用全局变量。
3. 耦合性：不要改变可变类型的参数，触发调用者希望这样做，函数可以改变传入的可变类型对象，但是向这样向全局变量一样，会导致调用者和被调用者之间的强耦合性。
4. 内聚性：每个函数都应该有一个单一的、统一的目标。
5. 大小：每个函数应该相对较小，如果函数过长应该考虑把它分开。
6. 耦合性：避免直接改变其他模块文件中的变量。

##### 递归函数

递归函数：直接或间接地调用自身以进行循环的函数。递归求和示例：

```python
def f(L):
    if not L:
        return 0
    else:
        return L[0] + f(L[1:])
f([1, 2 ,3]) #输出6
```

递归和循环语句：一般来说能用循环和递归来解决的，循环的效率更高且更易理解，但递归可以处理某些循环无法处理的情况，如计算嵌套列表中所有的数字的和：

```python
one = [1, [2, [3, 4],5], 6, [7, 8]]
def sumtree(L):
    sum = 0
    for x in L:
        if not isinstance(x, list): #判断x是否是list类型
            sum += x
        else:
            sum += sumtree(x)
    return sum
sumtree(one) #输出
```

