#### 类和面向对象编程（OOP）

##### 类的特性

1. 多重实例：类是一个产生对象的工厂，每当调用一个类的时候，就会产生一个有独立命名空间的新对象，每个由类产生的对象都能读取类的属性，并获得自己的命名空间来储存数据。
2. 通过继承进行定制：可以在类的外部以编写子类的方式，重新定义其属性进而扩充这个类。
3. 运算符重载：通过提供特定的协议方法，类可以定义对象来响应在内置类型上的一些运算。

##### `class` 语句创建类

1. `class` 语句创建类对象并将其赋值给一个名称。
2. `class` 语句内的赋值语句会创建类的属性。
3. 类属性提供了对象的状态和行为。

##### 类实例

1. 调用类对象会创建新的实例对象。
2. 每个实例对象继承了类的属性并获得自己的命名空间。
3. 在方法内对 `self` 属性做赋值运算会产生每个实例自己的属性。在类的方法函数内，第一个参数（按惯例称为 `self` ）会引用当前处理的实例对象。对 `self` 的属性做赋值运算，会创建或修改实例内的数据，而不是类的数据。

##### 创建类的示例

```python
class classEx1:
    def one(self, value):
        self.name = value
        print(self)
    def two(self):
        print(self.name)

ex1 = classEx1() #创建类示例
ex1.one("aioverg") #调用实例方法 one()，并给实例属性赋值；打印 self 的引用地址
ex1.two() #调用实例方法 two()；打印 aioverg
```

##### 继承的核心内容

1. 父类列在 `class` 语句头部的括号中。如果要继承另一个类的属性，只需要把类列在新的 `class` 语句头部行的括号中就可以了。
2. 类从其父类中继承属性。当属性访问时，现在子类中查找，子类中没有的化会在父类中查找。
3. 实例会继承所有可访问类的属性。每个实例会从创建它的类以及该类的父类中获得名称。当搜索一个名称时， `Python` 首先会检查实例，然后是它的类，最后是所有父类。
4. 每个 `obejct.attribute` 引用都会启动一个新的独立搜索。`Pyhotn` 会对每个属性访问表达式进行对类树的独立搜索。
5. 逻辑的修改是通过创建子类，而不是修改父类。如果在树中层次较低的子类中重新定义父类中的名称，子类就可替代并定制所继承的行为。

##### 继承类示例

```python
#继承 classEX 类
class classEx2(classEx1):
    def speak(self):
        print("hi", self.name)

ex2 = classEx2() #创建类实例
ex2.one("aioverg") #调用父类实例方法 one()，给实例属性 self.name 赋值，否则,classEx2类的 speak() 方法会找不到 name 属性。
ex2.speak() #调用实例方法 speak()；打印：hi aioverg
```

##### 重载运算符

1. 以双下划线命名的方法（`__X__`）是特殊的钩子，在 `Python` 类中实现运算符的重载是通过提供特殊命名的方法来拦截运算， `Python` 语言在每种运算符和特殊命名的方法之间，定义了固定不变的映射关系。
2. 当实例出现在内置运算中时，这类方法会自动被调用。例如，当实例对象继承了一个 `__add__` 方法，那么当对象出现在 `+` 表达式内时，该方法就会被调用，而该方法的返回值将作为相应表达式的结果。
3. 类可以重载大多数内置类型运算。 `Python` 中由几十种特殊运算符重载的方法名称，几乎可以截获并实现内置类型的所有运算。
4. 默认的运算符重载方法即不存在，也不需要。如果没有定义或继承运算符重载方法，那么类的实例将不支持相应的运算。例如，如果没有 `__add__` ，`+` 表达式就会引发异常。
5. 新式类由一些默认的运算符重载方法，但是不属于常见运算。
6. 运算符将类与 `Python` 的对象模型结合到一起。通过重载类型运算，可以让采用类实现的用户定义对象获得与内置对象一样的行为，者保证了与预期接口的一致性和兼容性。

运算符重载是可选的功能，主要被 `Python` 工具开发人员使用，而不是应用程序开发人员，不应该随意去使用它，除非需要模仿内置类型接口。

##### 重载运算符示例

- `__init__` 会在黄建新的实例时被调用，`self` 是新的`classEx3` 对象。
- `__add__` 会在`classEx3` 实例出现在 `+` 表达式中时被调用。
- `__str__` 会在打印一个对象的时候被调用。

```python
class classEx3(classEx2):
    def __init__(self, value):
        self.name = value
    def __add__(self, other): #self是加号左边的值，other是加号右边的值
        return classEx3(self.name + other)
    def __str__(self):
        return "eat" + self.name
    def mul(self, other):
        self.name = other
        
ex3 = classEx3("aioverg") #创建classEx3实例，并传入参数，此时参数会作为__init__()的参数
ex3.speak() #调用父类方法，打印：hi aioverg
print(ex3) #打印对象，调用__str__()，打印：hi aioverg! i am __str__

ex4 = ex3 + "ooo" #调用__add__()，返回classEx3(self.name + other)，即又创建了一个实例
ex4.speak()
print(ex4) #打印对象，调用__str__()，打印：hi aiovergooo! i am __str__

ex4.mul("apple") #调用mul()方法，重新给 self.name 赋值
ex4.speak() #打印：hi apple
```

## p793