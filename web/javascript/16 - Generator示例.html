<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<style>
  * {
margin: 0;
padding: 0;
}

  /* 页面属性 */
  #main {
width: 750px;
margin: 0 auto;
      background-color: #ffffff;
/* background-color: #f7f7f7; */
}

  /* 标题属性 */
  h1, h2, h3, h4, h5, h6 {
      margin: 6px 0;
  }

  /* 段落属性 */
  p {
      margin: 12px 0;
  }

  /* 图片属性 */
  img {
      width: 100%;
  }

  /* 媒体查询，响应式 */
@media screen and (max-width: 750px) {
#main {
  width: 95%;
}
}
  @media screen and (max-width: 425px) {
#main {
  width: 95%;
}
  }

  /* 列表属性 */
  ol li ol, ul li ul {
      padding: 0 0 0 18px;
  }
  ul p, ol p {
      margin: 0;
  }
  ul, ol {
      margin: 12px 18px;
      /* list-style-position: inside; */
  }
  ul ul, ol ol {
      margin: 0;
  }
  li ul, li ol {
      margin-top: 0;
      margin-bottom: 0;
  }

  /* 表格属性 */
  table {
      border-collapse: collapse;
      border-spacing: 0px;
      width: 100%;
      overflow: auto;
      break-inside: auto;
      text-align: center;
      margin: 6px 0;
  }
  table th {
      border: 1px solid #dfe2e5;
  }
  table td {
      border: 1px solid #dfe2e5;
  }
  table tr:nth-child(2n),
  thead {
      background-color: #f8f8f8;
  }

  /* 代码属性 */
  pre {
      background-color: #f8f8f8;
      overflow: auto;
      margin: 6px 0;
      padding: 8px;
  }
  code {
      background-color: #f8f8f8;
      font-size: 14px;
  }
  
</style>
<title>16 - Generator示例</title></head>
<body id="main"><h4>Generator示例</h4>
<p>基本示例</p>
<pre><code class='language-javascript' lang='javascript'>function* example(args){  //function关键字与函数名之间的*号是Generator的标志
    console.log(args)
    yield args  //yield、return关键字指定函数的内部状态，调用next()方法每次移动一个状态
    console.log(&#39;two&#39;)
    let arg = yield &#39;two&#39;  //下一个yield的next传入的参数会作为本次yield的返回值，
    console.log(arg)
    yield &#39;thr&#39;  //可以向next()传入参数，参数会作为上一个yield的返回值。
    return &#39;ending&#39;  //next()方法走到这里终止，状态不再改变
}
const ex1 = example(&#39;one&#39;)  //传入参数，并运行Generator
ex1.next( res =&gt; {console.log(res)})  //执行一个yield之前的代码，并接受yield的返回值
ex1.next()  //向yield传参数
ex1.next(&#39;thr&#39;)  //可以向next传参，参数作为上一个yield表达式的返回值。
for(let i of ex1){console.log(i)}  //可以遍历yield执行
</code></pre>
<p>基本示例</p>
<pre><code class='language-javascript' lang='javascript'>function* example(){
    console.log(&quot;one&quot;)
    yield &#39;one&#39;
    try{
        console.log(&quot;two&quot;)
        yield &#39;two&#39;
    }catch(error){
        console.log(&#39;内部捕获错误&#39;, error)
    }
    console.log(&quot;thr&quot;)
    yield &#39;thr&#39;
}
const ex1 = example()
ex1.next()  //throw抛出的错误若要被Generator内部捕获，必须执行一次next()
ex1.throw(&#39;错误&#39;)  //抛出错误，会执行一次next()，且将Generator变为执行完毕。抛出错误时，若Generator内部没有try...catch代码块，错误会被外部try...catch捕获，或默认错误程序捕获。
try{  //内部不定义try...catch时外部定义的try...catch，当二者同时存在时优先被外部捕获。
    ex1.throw(&#39;错误&#39;)
}catch(error){
    console.log(&#39;外部捕获错误&#39;, error)
}
</code></pre>
<p>实现斐波那契</p>
<pre><code class='language-javascript' lang='javascript'>function* fibonacci() {
  let [prev, curr] = [0, 1];
  for (;;) {
    yield curr;
    [prev, curr] = [curr, prev + curr];
  }
}

for (let n of fibonacci()) {
  if (n &gt; 1000) break;
  console.log(n);
}
</code></pre>
<p>&nbsp;</p>
</body>
</html>